{"mappings":";;;;;;;;ACAO,MAAM,4CAAqB,CAAC,KAAK;IACtC,IAAI;QACF,IAAI,OAAO;YACT,aAAa,OAAO,CAAC,KAAK;YAE1B,OAAO;QACT;QAEA,OAAO,aAAa,OAAO,CAAC;IAC9B,EAAE,OAAO,GAAG;QACV,OAAO;IACT;AACF;;;ADVA,uCAAuC;AAEvC,8CAA8C;AAC9C,oDAAoD;AAEpD,MAAM,8BAAQ,CAAC;AACf,MAAM,oCAAc,OAAO,WAAW;AAE/B,MAAM,4CAAO,CAAC,UAErB;AAMO,MAAM,2CAAM,CAAC;IAClB,IAAI,CAAC,qCAAe,CAAC,WACnB;IAGF,2BAAK,CAAC,UAAU,GAAG;IACnB,kCAAY,IAAI,CAAC,YAAY;AAC/B;AAMO,MAAM,4CAAM,CAAC,UAAU,YAAY,EAAE;IAC1C,IAAI;IACJ,MAAM,WAAW,SAAS,OAAO,CAAC,iBAAiB;IACnD,MAAM,eAAe,aAAa,CAAC,SAAS;IAC5C,MAAM,cACJ,kCAAY,MAAM,CAAC,UAAU,IAC7B,kCAAY,gBAAgB,CAAC,YAAY,QAAQ,CAAC,EAAE;IAEtD,IACE,EAAE,WAAW,CAAC,sCACb,YAAY,CAAA,GAAA,yCAAiB,EAAE,qBAAqB,oBACpD,YAAY,CAAC,IAAI,QAAQ,CAAC,uBAC1B,aAAa,CAAC,eACf,CAAC,cAED;IAGF,IAAI,aAAa;QACf,cACE,EAAE,UAAU,CACV,kCAAY,OAAO,CACjB,iBACA,kCAAY,MAAM,CAAC,UAAU,GAAG,YAAY,YAAY,UAE1D,eAAe;QAEnB,IAAI,cAAc,IAAI;YACpB,kCAAY,aAAa,CAAC;YAC1B,kCAAY,UAAU,CAAC,YAAY;QACrC;IACF,OACE,cAAc,KAAK,GAAG,KAAK,IAAI,QAAQ,CAAC;IAG1C,IAAI,cAAc;IAElB;;;;GAIC,GACD,IAAI,UACF,cAAc,CAAC,aAAa,GAAG;AAEnC","sources":["src/index.ts","src/utils.ts"],"sourcesContent":["import { attachEvents } from './events';\nimport { accessLocalStorage } from './utils';\n// import {InitParams} from \"../types\";\n\n// const CACHE_CHECK_KEY = 'amo-cached-front';\n// const FRONTEND_VERSION = APP.constant('version');\n\nconst marks = {};\nconst performance = window.performance;\n\nexport const init = (params) => {\n\n};\n\n// используется для установки метки начала замера\n// нужно только если измеряем кастомные метрики\n// если вызвать только `msr`, то замер будет\n// посчитан от старта загрузки страницы\nexport const mrk = (mark_name) => {\n  if (!performance || !mark_name) {\n    return;\n  }\n\n  marks[mark_name] = true;\n  performance.mark(mark_name + '_mark');\n};\n\n// метод окончания замера\n// принимает параметр `log_type`,\n// который должен быть\n// одним из предустановленных выше в `ALLOWED_TYPES`\nexport const msr = (log_type, perf_mark = '') => {\n  let render_time;\n  const no_cache = log_type.indexOf('NO_CACHE_') === 0;\n  const allowed_type = ALLOWED_TYPES[log_type];\n  const custom_mark =\n    performance.timing[perf_mark] ||\n    performance.getEntriesByName(perf_mark + '_mark')[0];\n\n  if (\n    _.isUndefined(performance) ||\n    (no_cache && accessLocalStorage(CACHE_CHECK_KEY) === FRONTEND_VERSION) ||\n    (no_cache && !APP.constant('front-load-start')) ||\n    (perf_mark && !custom_mark) ||\n    !allowed_type\n  ) {\n    return;\n  }\n\n  if (custom_mark) {\n    render_time =\n      _.propertyOf(\n        performance.measure(\n          'meter_measure',\n          performance.timing[perf_mark] ? perf_mark : perf_mark + '_mark'\n        )\n      )('duration') || -1;\n\n    if (render_time > -1) {\n      performance.clearMeasures('meter_measure');\n      performance.clearMarks(perf_mark + '_mark');\n    }\n  } else {\n    render_time = Date.now() - APP.constant('front-load-start');\n  }\n\n  log(allowed_type, render_time);\n\n  /**\n   * Для логов, которые должны быть залогированы\n   * без кеша проставим флаг, чтобы в следующий раз\n   * уже не отправлять\n   */\n  if (no_cache) {\n    LOG_DISALLOWED[allowed_type] = true;\n  }\n};\n","export const accessLocalStorage = (key, value) => {\n  try {\n    if (value) {\n      localStorage.setItem(key, value);\n\n      return true;\n    }\n\n    return localStorage.getItem(key);\n  } catch (e) {\n    return false;\n  }\n};"],"names":[],"version":3,"file":"index.js.map"}